
#include "CommandParser.h"

#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <iostream>
#include <string>
#include <errno.h>
#include <stdio.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <iomanip>
#include <cstring>
#include <list>
#include <sstream>

using namespace std;

void spawn(string name="John Doe");

static void reaper(int sig, siginfo_t *siginfo, void *context) {

    //cout << "A child has died!\n";

    // clear zero or more waiting dead children
    while (waitpid(-1, NULL, WNOHANG) > 0) {}

}

int main() {

    string ps1 = "$> ";
    struct sigaction sa_reaper;

    sa_reaper.sa_sigaction = &reaper;
    sigemptyset(&sa_reaper.sa_mask);
    sa_reaper.sa_flags = 0;

    sigaction(SIGCHLD, &sa_reaper, NULL);

    cout << "So you think you're ready to be a parent?\n"
         << "\n"
         << "Lets see if you can keep your children from starving...\n"
         << "\n"
         << "Enter 'h' for the help menu.\n";

    while (1) {
        string line;
        string cmd;
        string arg;

        // TODO display alive child summary

        cout << ps1;

        while (1) {
            getline(cin, line);
            if (cin.fail() or cin.bad()) { // *
                cin.clear();
            } else {
                break;
            }
        }
        /*
         * * When the SIGCHLD interrupt is executed the bad bit
         *   will be set on cin.  This is fixed by using clear().
         */

        CommandParser cp(line);

        cmd = cp.getCommand();
        arg = cp.getArgument();

        if (cmd == "f") {
            // feed a pet
            
            if (arg.empty()) {
                cout << "Which child do you want to feed?.\n";
            }  else {
                //pid = arg;
                //kill(pid, SIGHUP);
                // TODO 
            }
        } else if (cmd == "s") {
            // spawn a new child

            spawn(arg);

        } else if (cmd == "sn") {
            // create n John Does

            int n;
            stringstream ss(arg);
            
            ss >> n;

            while (n-- > 0) {
                spawn();
            }

        } else if (cmd == "s+") {
            list<string> names;

            cout << "Enter each new child on a single line\n"
                 << "a blank line quits.\n";

            string ps1 = ">> ";

            /*
             * All the names are read in BEFORE any are spawned.
             * This was done because output may be generated by the
             * children which can make entering input difficult.
             */
            while (1) {
                cout << ps1;

                getline(cin, line);

                if (line.empty())
                    break;

                names.push_front(line);
            }

            for(list<string>::iterator it = names.begin(); it != names.end();it++) {
                spawn(*it);
            }
        } else if (cmd == "q") {
            // quit

            break;
        } else if (cmd == "h") {
            // help menu
            cout << "Help Menu:\n"
                 << "\n"
                 << " h          help menu\n"
                 << " f <id>     feed a child\n"
                 << " s <name>   spawn a single named child\n"
                 << " s+         spawn multiple named children\n"
                 << " sn <n>     spawn n children unnamed children\n"
                 << " q          quit\n";
        }
    }

    // TODO - display obituaries
    return 0;
}

void spawn(string name)
{
    pid_t pid = fork();

    if (0 == pid) {
        // child

        //execl("./child", "./child", arg.c_str(), 0);
        execlp("./child", "./child", name.c_str(), 0);

        // will only get here if there was an error
        perror(0);
        exit(1);
    } else {
        // parent
        // TODO store the pid and name
    }
}
